#!/bin/bash
shopt -s extglob


####################################################################################################
# GENERIC FUNCTIONS

debug() {
    if test -n "$debug"; then
        echo "$@" >&2
    fi
}

assert() {
    if "$@"; then
        :
    else
        die "assertion failed: " "$@"
    fi
}

sh_escape() {
    if test "${1//[ \'\"\\]/}" = "$1"; then
        echo -n "$1"
    else
        if test "${1//\"/}" = "$1"; then
            echo -n "\"$1\""
        else
            if test "${1//\'/}" = "$1"; then
                echo -n "'$1'"
            else
                printf "%q" "$1"
            fi
        fi
    fi
}

sh_escape_all() {
    for arg in "$@"; do
        sh_escape "$arg"
        echo -n " "
    done
}


####################################################################################################
# GENERIC GIT HELPER FUNCTIONS

fancy_oneline='tformat:    %Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%ad) %C(bold blue)<%an>%Creset'
squashmsg_format='tformat:* %h %ad %s <%ae>'

# copy_commit <commit> <tree> ["-p<parent1> -p<parent2>..."]
copy_commit() {
    # We're going to set some environment vars here, so
    # do it in a subshell to get rid of them safely later
    debug copy_commit "{$1}" "{$2}" "{$3}"
    git log -1 --pretty=format:'%an%n%ae%n%ad%n%cn%n%ce%n%cd%n%s%n%n%b' "$1" |
    (
        read GIT_AUTHOR_NAME
        read GIT_AUTHOR_EMAIL
        read GIT_AUTHOR_DATE
        read GIT_COMMITTER_NAME
        read GIT_COMMITTER_EMAIL
        read GIT_COMMITTER_DATE
        export  GIT_AUTHOR_NAME \
            GIT_AUTHOR_EMAIL \
            GIT_AUTHOR_DATE \
            GIT_COMMITTER_NAME \
            GIT_COMMITTER_EMAIL \
            GIT_COMMITTER_DATE
        (echo -n "$commit_msg_prefix"; cat) |
        git commit-tree "$2" $3  # reads the rest of stdin
    ) || die "Can't copy commit $1"
}

toptree_for_commit() {
    commit="$1"
    git log -1 --pretty=format:'%T' "$commit" -- || exit $?
}

subtree_for_commit() {
    (
        commit="$1"
        dir="$2"
        git ls-tree "$commit" -- "$dir" |
        while read mode type tree name; do
            assert [ "$name" = "$dir" ]
            assert [ "$type" = "tree" -o "$type" = "commit" ]
            [ "$type" = "commit" ] && continue  # ignore submodules
            echo $tree
            break
        done
    )
}


####################################################################################################
# GITDIR-SPECIFIC HELPERS

# subdir=<subdir> remote=<remote> branch=<branch> find_base_commit
find_base_commit() {
    for commit in $(git rev-list --topo-order --reverse HEAD); do
        tree="$(subtree_for_commit "$commit" "$subdir")"
        # debug "master commit $commit, tree $tree"
        if test -n "$tree"; then
            eval "tree_$tree=$commit"
        fi
    done

    for commit in $(git rev-list --topo-order $remote/$branch); do
        tree="$(toptree_for_commit "$commit" "$subdir")"
        master_commit="$(eval echo "\${tree_$tree}")"
        # debug "subdir commit $commit, tree $tree, master_commit $master_commit"
        if test -n "$master_commit"; then
            echo "$tree $commit $master_commit"
            exit
        fi
    done
}

# subdir=<subdir> remote=<remote> branch=<branch> base=<base-commit> find_outgoing_commits
find_outgoing_commits() {
    if test -n "$base"; then
        git rev-list --topo-order --reverse --no-merges "^$base" HEAD -- "$subdir"
    fi
}

# subdir=<subdir> remote=<remote> branch=<branch> base=<base-commit> find_incoming_commits
find_incoming_commits() {
    base_arg=""
    test -n "$base_in_subdir" && base_arg="^$base_in_subdir"
    git rev-list --topo-order --reverse --no-merges $base_arg "$remote/$branch"
}

# subdir=<subdir> base=<base-commit> outgoing_commits=<commits> create_outgoing_commits
create_outgoing_commits() {
    last_commit="$incoming_HEAD"
    echo "$outgoing_commits" |
    while read commit; do
        tree="$(subtree_for_commit $commit "$subdir")"
        if test -n "$tree"; then
            debug "    subtree is: $tree"
            last_commit="$(commit_msg_prefix="" copy_commit "$commit" "$tree" "-p $last_commit")"
            echo "$last_commit"
            debug "    new commit is: $last_commit"
        else
            debug "    no subtree found"
        fi
    done
}

# subdir=<subdir> base=<base-commit> outgoing_commits=<commits> create_outgoing_commits
create_incoming_commits_for_linear_method() {
    export GIT_INDEX_FILE="$TEMP_INDEX_FILE"  # use a temporary index here to avoid
    git read-tree "$HEAD"

    commit_msg_prefix="[$remote] "  # used by copy_commit

    last_commit="$HEAD"
    echo "$incoming_commits" |
        while read commit; do
            debug "git ls-files -- \"$subdir/\" | xargs git update-index --remove"
            old_files="$(git ls-files -- "$subdir/")" || { echo "fail"; break; }
            echo "$old_files" | xargs git update-index --force-remove || { echo "fail"; break; }
            debug "git read-tree --prefix=\"$subdir/\" $commit"
            git read-tree --prefix="$subdir/" $commit || { echo "fail"; break; }
            tree="$(git write-tree)"
            debug "    tree is: $tree"
            last_commit="$(copy_commit "$commit" "$tree" "-p $last_commit")"
            echo "$last_commit"
            debug "    new commit is: $last_commit"
        done
}

format_squashed_incoming_commit_message() {
    echo "$import_message"
    echo
    git --no-pager log --no-walk=unsorted --date=short --pretty="$squashmsg_format" $incoming_commits
}

# handle_subdir_option <subdir> <option> <value> <default> <force-save?>
# $1 = <subdir>, $2 = <option>, $3 = <value>, $4 = <default>, $5 = <force-save?>
handle_subdir_option() {
    saved="$(git config "subdir.$1.$2")"
    if test -n "$3"; then
        test "$3" = "$saved" || git config "subdir.$1.$2" "$3"
        echo "$3"
    elif test -n "$saved"; then
        echo "$saved"
    else
        if $5; then
            test "$4" = "$saved" || git config "subdir.$1.$2" "$4"
        fi
        echo "$4"
    fi
}

run() {
    comment="$1"; shift
    dry=""; $dry_run && dry="(dry) "
    echo "$comment:" >&2
    echo "    ${dry}$(sh_escape_all "$@")" >&2
    if ! $dry_run; then
        "$@" || die "** Command failed. Stop."
    fi
}

run_with_result() {
    comment="$1"; shift
    dry=""; $dry_run && dry="(dry) "
    echo "$comment:" >&2
    echo "    ${dry}$(sh_escape_all "$@")" >&2
    if ! $dry_run; then
        result="$("$@")" || die "** Command failed. Stop."
    else
        result=""
    fi
}

run_or_skip() {
    if $1; then
        comment="$2"; shift; shift; shift
        run "$comment" "$@"
    else
        echo "$3" >&2
    fi
}

expand_value() {
    value="$1"
    lf="
"
    value="${value//<remote>/$remote}"
    value="${value//<branch>/$branch}"
    value="${value//<subdir>/$subdir}"
    value="${value//<prefix>/$prefix}"
    value="${value//<lf>/$lf}"
    value="${value//<lflf>/$lf$lf}"
    value="${value//<commit>/$incoming_HEAD_short}"
    echo "$value"
}

expand_config() {
    expand_value "$(git config --get "$1" || echo "$2")"
}

####################################################################################################
# OPERATIONS

# subdir=<subdir> [url=<url>] [remote=<remote>] [branch=<branch>] process_subdir
process_subdir() {(
    # remove trailing slash, it will interfer with --prefix option to git read-tree
    subdir="${subdir%/}"

    remote="$(handle_subdir_option "$subdir" remote "$remote" "$(basename "$subdir")" true)"
    branch="$(handle_subdir_option "$subdir" branch "$branch" master true)"
    method="$(handle_subdir_option "$subdir" method "$method" squash true)"
    prefix="$(handle_subdir_option "$subdir" prefix "$prefix" '[<remote>] ' true)"

    prefix="$(expand_value "$prefix")"

    debug "Processing folder $subdir against remote branch $remote/$branch, method = $method."

    case "$method" in
        merge | squash | linear) initial_method=$method;;
        squash,merge)  method=merge; initial_method=squash;;
        squash,linear) method=linear; initial_method=squash;;
        *) die "** Unknown --method '$method'. Run with -h for usage.";;
    esac

    saved_url="$(git config "remote.$remote.url")"
    if test -n "$url"; then
        if test -z "$saved_url"; then
            dry_run=false run "Add remote '$remote'" \
                git remote add "$remote" "$url"
        elif ! test "$url" = "$saved_url"; then
            run "Update remote '$remote' to point to a new URL" \
                git remote set-url "$remote" "$url"
        fi
        if test -z "$(git config --get "remote.$remote.tagopt")"; then
            git config "remote.$remote.tagopt" --no-tags
        fi
    elif test -z "$saved_url"; then
        die "** Remote '$remote' does not exist. Please provide --url <url> or set up the remote yourself."
    fi

    dry_run=false run_or_skip "$fetch" "Fetching updates from the server" "Skipping 'git fetch' because of --no-fetch." \
        git fetch --no-tags "$remote"

    HEAD="$(git rev-parse HEAD)"

    # base="$(git merge-base HEAD $remote/$branch)"
    read base_tree base_in_subdir base < <(find_base_commit)
    if test -n "$base"; then
        echo "Here's the most recently imported/exported commit in our repo:"
        git --no-pager log -1 --pretty="$fancy_oneline" --date=short "$base"
        echo "Here's its counterpart in the subdir repo:"
        git --no-pager log -1 --pretty="$fancy_oneline" --date=short "$base_in_subdir"
    else
        echo "No imported or exported commits found. Perhaps this is a first-time import."
    fi

    # if there's no base commit, this is an initial import
    test -z "$base" && initial=true || initial=false

    $initial && method=$initial_method

    outgoing_commits="$(find_outgoing_commits)"
    if test -n "$outgoing_commits"; then
        echo "Outgoing commits:"
        git --no-pager log --no-walk=unsorted --pretty="$fancy_oneline" --date=short $outgoing_commits
    else
        echo "No outgoing commits."
    fi

    incoming_commits="$(find_incoming_commits)"
    incoming_HEAD="$(git rev-parse $remote/$branch)"
    test -n "$incoming_HEAD" && incoming_tree="$(toptree_for_commit $incoming_HEAD)"
    if test -n "$incoming_commits"; then
        echo "Incoming commits:"
        git --no-pager log --no-walk=unsorted --pretty="$fancy_oneline" --date=short $incoming_commits
    else
        echo "No incoming commits."
    fi

    if test -n "$incoming_commits" -a -n "$outgoing_commits"; then
        if $force; then
            echo "    There are both incoming and outgoing commits."
            echo "    Proceeding because of --force."
        else
            echo "Houston, we have a problem!"
            echo
            echo "    There are both incoming and outgoing commits."
            echo "    Please read the docs about resolving this case."
            echo "    Refusing to do anything to avoid screwing up."
            echo
            echo "    You can use --force to override, but pls be very sure!"
            echo
            echo "    FYI, here's the most recently imported/exported commit:"
            git --no-pager log -1 --pretty="$fancy_oneline" --date=short "$base"
            exit 1
        fi
    fi

    if test -n "$outgoing_commits"; then
        if test "$mode" = export -o "$mode" = sync; then
            echo
            echo "Exporting commits:"
            new_commit="$(create_outgoing_commits | tail -1)"
            if ! test "$new_commit" = "$base"; then
                new_commit_count=$(expr $(git rev-list $base..$new_commit | wc -l))
                git --no-pager log --pretty=oneline -$new_commit_count $new_commit
                run "Pushing new commits to the server" \
                    git push $remote $new_commit:$branch
                echo "Export finished."
            else
                echo "No new commits found."
            fi
        else
            echo
            echo "Skipping export because it was not requested; use -S or -E to run export."
        fi
    fi

    if test -n "$incoming_commits"; then
        incoming_HEAD_short="$(git describe --always "$incoming_HEAD")"
        if $initial; then
            import_message="$(expand_config subdir.initialImportMessage '<prefix>Import <commit>')"
        else
            import_message="$(expand_config subdir.importMessage '<prefix>Update to <commit>')"
        fi

        if test "$mode" = import -o "$mode" = sync; then
            case $method in
            squash)
                run "Delete the previous version (so that it does not interfere with git read-tree)" \
                    git rm --ignore-unmatch -r -q $subdir

                run "Copy the new version into the subdir" \
                    git read-tree --prefix=$subdir/ -u $remote/$branch

                run "Commit the changes" \
                    git commit -m "$(format_squashed_incoming_commit_message)"
                ;;

            linear)
                new_commits="$(create_incoming_commits_for_linear_method)"
                new_commits_count=$(expr $(echo "$new_commits" | wc -l))
                new_commit="$(echo "$new_commits" | tail -1)"

                test "$new_commit" = "fail" && die "** Importing failed."

                echo "Imported commits:"
                git --no-pager log --no-walk=unsorted --pretty="$fancy_oneline" --date=short $new_commits

                run "Add the imported commits to the current branch" \
                    git update-ref -m "$import_message" HEAD "$new_commit" "$HEAD"
                run "Update the working directory" \
                    git read-tree --reset -u HEAD
                ;;

            merge)
                run "Merge with the remote branch" \
                    git merge -s ours --no-commit $remote/$branch

                run "Delete the previous version (so that it does not interfere with git read-tree)" \
                    git rm --ignore-unmatch -r -q $subdir

                run "Copy the new version into the subdir" \
                    git read-tree --prefix=$subdir/ -u $remote/$branch

                run "Commit the changes" \
                    git commit --no-status -m "$import_message"
                ;;
            esac
        else
            echo
            echo "Skipping import because it was not requested; use -S or -I to run import."
        fi
    fi
)}


####################################################################################################
# PARSE COMMAND LINE

OPTS_SPEC="\
git subdir [--sync | --import | --export] [<subdir> [--remote <remote>] [--branch branch] [--url <url>]]

Syncs subdirectories of the current repo with their own separate repositories.
See https://github.com/andreyvit/git-subdir for details.
--
  Mode of operation:
S,sync        sync (import and/or export)
I,import      import changes
E,export      export changes
Q,status      display the current status (the default mode), aka 'query' mode

  Subdirectory options (saved into git config automatically):
r,remote=     remote name
b,branch=     remote branch name
url=          remote url (if you want git-subdir to set up git-remote automatically)
M,method=     importing method
prefix=       prefix for imported commit msgs

  Expansions for --prefix: <remote>, <branch>, <subdir>.

  Option defaults: -r \$(basename \$subdir) -b master -M squash --prefix '[<remote>] '

  Available methods for -M: merge, squash, linear. You can also use -Msquash,linear or -Msquash,merge

  Other options:
F,no-fetch    don't run 'git fetch'
fetch         override --no-fetch
n,dry-run     don't execute anything, merely print the commands that would be executed
force         force importing even in the presence of incoming changes

  Configuration options (git config): subdir.importMessage, subdir.initialImportMessage.

  General options:
h,help        show the help
d,debug       show debug messages
"
eval "$(echo "$OPTS_SPEC" | git rev-parse --parseopt -- "$@" || echo exit $?)"


####################################################################################################
# GIT STARTUP

PATH=$PATH:$(git --exec-path)
. git-sh-setup
require_work_tree

TEMP_INDEX_FILE="$GIT_DIR/index.gitsubdir.tmp"


####################################################################################################
# PROCESS COMMAND LINE OPTIONS

quiet=
debug=
remote=
branch=
method=
prefix=
url=
fetch=true
dry_run=false
mode=status
force=false

echo "args: $*"

while [ $# -gt 0 ]; do
    opt="$1"; shift
    case "$opt" in
        -q) quiet=true;;
        -d) debug=true;;
        -r) remote="$1"; shift;;
        -b) branch="$1"; shift;;
        --url) url="$1"; shift;;
        --prefix) prefix="$1"; shift;;
        --fetch) fetch=true;;
        -F) fetch=false;;
        -n) dry_run=true;;
        -Q) mode=status;;
        -S) mode=sync;;
        -I) mode=import;;
        -E) mode=export;;
        --force) force=true;;
        --no-force) force=false;;
        -M) method="$1"; shift;;
        --) break;;
        *) die "Unexpected option: $opt" ;;
    esac
done

if $force && ! test "$mode" = "import"; then
    die "--force can only be used in --import/-I mode."
fi

if test $# -gt 0; then
    subdir="$1"
    test -n "$subdir" || die "You must provide a non-empty <subdir>."

    process_subdir "$subdir"
else
    echo "Processing all subdirs is not implemented yet. Run 'git subdir -h' for usage."
fi
